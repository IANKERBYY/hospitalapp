{"ast":null,"code":"import{CALLBACK_TYPE}from'../gesture';import{Reanimated}from'../reanimatedWrapper';import{GestureStateManager}from'../gestureStateManager';import{State}from'../../../State';import{TouchEventType}from'../../../TouchEventType';import{tagMessage}from'../../../utils';function getHandler(type,gesture){'worklet';switch(type){case CALLBACK_TYPE.BEGAN:return gesture.onBegin;case CALLBACK_TYPE.START:return gesture.onStart;case CALLBACK_TYPE.UPDATE:return gesture.onUpdate;case CALLBACK_TYPE.CHANGE:return gesture.onChange;case CALLBACK_TYPE.END:return gesture.onEnd;case CALLBACK_TYPE.FINALIZE:return gesture.onFinalize;case CALLBACK_TYPE.TOUCHES_DOWN:return gesture.onTouchesDown;case CALLBACK_TYPE.TOUCHES_MOVE:return gesture.onTouchesMove;case CALLBACK_TYPE.TOUCHES_UP:return gesture.onTouchesUp;case CALLBACK_TYPE.TOUCHES_CANCELLED:return gesture.onTouchesCancelled;}}function touchEventTypeToCallbackType(eventType){'worklet';switch(eventType){case TouchEventType.TOUCHES_DOWN:return CALLBACK_TYPE.TOUCHES_DOWN;case TouchEventType.TOUCHES_MOVE:return CALLBACK_TYPE.TOUCHES_MOVE;case TouchEventType.TOUCHES_UP:return CALLBACK_TYPE.TOUCHES_UP;case TouchEventType.TOUCHES_CANCELLED:return CALLBACK_TYPE.TOUCHES_CANCELLED;}return CALLBACK_TYPE.UNDEFINED;}function runWorklet(type,gesture,event,...args){'worklet';const handler=getHandler(type,gesture);if(gesture.isWorklet[type]){handler===null||handler===void 0?void 0:handler(event,...args);}else if(handler){console.warn(tagMessage('Animated gesture callback must be a worklet'));}}function isStateChangeEvent(event){'worklet';return event.oldState!=null;}function isTouchEvent(event){'worklet';return event.eventType!=null;}export function useAnimatedGesture(preparedGesture,needsRebuild){if(!Reanimated){return;}const sharedHandlersCallbacks=Reanimated.useSharedValue(null);const lastUpdateEvent=Reanimated.useSharedValue([]);const stateControllers=[];const callback=event=>{'worklet';const currentCallback=sharedHandlersCallbacks.value;if(!currentCallback){return;}for(let i=0;i<currentCallback.length;i++){const gesture=currentCallback[i];if(event.handlerTag!==gesture.handlerTag){continue;}if(isStateChangeEvent(event)){if(event.oldState===State.UNDETERMINED&&event.state===State.BEGAN){runWorklet(CALLBACK_TYPE.BEGAN,gesture,event);}else if((event.oldState===State.BEGAN||event.oldState===State.UNDETERMINED)&&event.state===State.ACTIVE){runWorklet(CALLBACK_TYPE.START,gesture,event);lastUpdateEvent.value[gesture.handlerTag]=undefined;}else if(event.oldState!==event.state&&event.state===State.END){if(event.oldState===State.ACTIVE){runWorklet(CALLBACK_TYPE.END,gesture,event,true);}runWorklet(CALLBACK_TYPE.FINALIZE,gesture,event,true);}else if((event.state===State.FAILED||event.state===State.CANCELLED)&&event.state!==event.oldState){if(event.oldState===State.ACTIVE){runWorklet(CALLBACK_TYPE.END,gesture,event,false);}runWorklet(CALLBACK_TYPE.FINALIZE,gesture,event,false);}}else if(isTouchEvent(event)){if(!stateControllers[i]){stateControllers[i]=GestureStateManager.create(event.handlerTag);}if(event.eventType!==TouchEventType.UNDETERMINED){runWorklet(touchEventTypeToCallbackType(event.eventType),gesture,event,stateControllers[i]);}}else{runWorklet(CALLBACK_TYPE.UPDATE,gesture,event);if(gesture.onChange&&gesture.changeEventCalculator){var _gesture$changeEventC;runWorklet(CALLBACK_TYPE.CHANGE,gesture,(_gesture$changeEventC=gesture.changeEventCalculator)===null||_gesture$changeEventC===void 0?void 0:_gesture$changeEventC.call(gesture,event,lastUpdateEvent.value[gesture.handlerTag]));lastUpdateEvent.value[gesture.handlerTag]=event;}}}};const event=Reanimated.useEvent(callback,['onGestureHandlerStateChange','onGestureHandlerEvent'],needsRebuild);preparedGesture.animatedEventHandler=event;preparedGesture.animatedHandlers=sharedHandlersCallbacks;}","map":{"version":3,"names":["CALLBACK_TYPE","Reanimated","GestureStateManager","State","TouchEventType","tagMessage","getHandler","type","gesture","BEGAN","onBegin","START","onStart","UPDATE","onUpdate","CHANGE","onChange","END","onEnd","FINALIZE","onFinalize","TOUCHES_DOWN","onTouchesDown","TOUCHES_MOVE","onTouchesMove","TOUCHES_UP","onTouchesUp","TOUCHES_CANCELLED","onTouchesCancelled","touchEventTypeToCallbackType","eventType","UNDEFINED","runWorklet","event","args","handler","isWorklet","console","warn","isStateChangeEvent","oldState","isTouchEvent","useAnimatedGesture","preparedGesture","needsRebuild","sharedHandlersCallbacks","useSharedValue","lastUpdateEvent","stateControllers","callback","currentCallback","value","i","length","handlerTag","UNDETERMINED","state","ACTIVE","undefined","FAILED","CANCELLED","create","changeEventCalculator","_gesture$changeEventC","call","useEvent","animatedEventHandler","animatedHandlers"],"sources":["C:\\Users\\pablo\\HospitalApp\\node_modules\\react-native-gesture-handler\\lib\\module\\handlers\\gestures\\GestureDetector\\useAnimatedGesture.ts"],"sourcesContent":["import { HandlerCallbacks, CALLBACK_TYPE } from '../gesture';\nimport { Reanimated } from '../reanimatedWrapper';\nimport {\n  GestureTouchEvent,\n  GestureUpdateEvent,\n  GestureStateChangeEvent,\n} from '../../gestureHandlerCommon';\nimport {\n  GestureStateManager,\n  GestureStateManagerType,\n} from '../gestureStateManager';\nimport { State } from '../../../State';\nimport { TouchEventType } from '../../../TouchEventType';\nimport { tagMessage } from '../../../utils';\nimport { AttachedGestureState } from './types';\n\nfunction getHandler(\n  type: CALLBACK_TYPE,\n  gesture: HandlerCallbacks<Record<string, unknown>>\n) {\n  'worklet';\n  switch (type) {\n    case CALLBACK_TYPE.BEGAN:\n      return gesture.onBegin;\n    case CALLBACK_TYPE.START:\n      return gesture.onStart;\n    case CALLBACK_TYPE.UPDATE:\n      return gesture.onUpdate;\n    case CALLBACK_TYPE.CHANGE:\n      return gesture.onChange;\n    case CALLBACK_TYPE.END:\n      return gesture.onEnd;\n    case CALLBACK_TYPE.FINALIZE:\n      return gesture.onFinalize;\n    case CALLBACK_TYPE.TOUCHES_DOWN:\n      return gesture.onTouchesDown;\n    case CALLBACK_TYPE.TOUCHES_MOVE:\n      return gesture.onTouchesMove;\n    case CALLBACK_TYPE.TOUCHES_UP:\n      return gesture.onTouchesUp;\n    case CALLBACK_TYPE.TOUCHES_CANCELLED:\n      return gesture.onTouchesCancelled;\n  }\n}\n\nfunction touchEventTypeToCallbackType(\n  eventType: TouchEventType\n): CALLBACK_TYPE {\n  'worklet';\n  switch (eventType) {\n    case TouchEventType.TOUCHES_DOWN:\n      return CALLBACK_TYPE.TOUCHES_DOWN;\n    case TouchEventType.TOUCHES_MOVE:\n      return CALLBACK_TYPE.TOUCHES_MOVE;\n    case TouchEventType.TOUCHES_UP:\n      return CALLBACK_TYPE.TOUCHES_UP;\n    case TouchEventType.TOUCHES_CANCELLED:\n      return CALLBACK_TYPE.TOUCHES_CANCELLED;\n  }\n  return CALLBACK_TYPE.UNDEFINED;\n}\n\nfunction runWorklet(\n  type: CALLBACK_TYPE,\n  gesture: HandlerCallbacks<Record<string, unknown>>,\n  event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent,\n  ...args: unknown[]\n) {\n  'worklet';\n  const handler = getHandler(type, gesture);\n  if (gesture.isWorklet[type]) {\n    // @ts-ignore Logic below makes sure the correct event is send to the\n    // correct handler.\n    handler?.(event, ...args);\n  } else if (handler) {\n    console.warn(tagMessage('Animated gesture callback must be a worklet'));\n  }\n}\n\nfunction isStateChangeEvent(\n  event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n): event is GestureStateChangeEvent {\n  'worklet';\n  // @ts-ignore Yes, the oldState prop is missing on GestureTouchEvent, that's the point\n  return event.oldState != null;\n}\n\nfunction isTouchEvent(\n  event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n): event is GestureTouchEvent {\n  'worklet';\n  return event.eventType != null;\n}\n\nexport function useAnimatedGesture(\n  preparedGesture: AttachedGestureState,\n  needsRebuild: boolean\n) {\n  if (!Reanimated) {\n    return;\n  }\n\n  // Hooks are called conditionally, but the condition is whether the\n  // react-native-reanimated is installed, which shouldn't change while running\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const sharedHandlersCallbacks = Reanimated.useSharedValue<\n    HandlerCallbacks<Record<string, unknown>>[] | null\n  >(null);\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const lastUpdateEvent = Reanimated.useSharedValue<\n    (GestureUpdateEvent | undefined)[]\n  >([]);\n\n  // not every gesture needs a state controller, init them lazily\n  const stateControllers: GestureStateManagerType[] = [];\n\n  const callback = (\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent\n  ) => {\n    'worklet';\n\n    const currentCallback = sharedHandlersCallbacks.value;\n    if (!currentCallback) {\n      return;\n    }\n\n    for (let i = 0; i < currentCallback.length; i++) {\n      const gesture = currentCallback[i];\n\n      if (event.handlerTag !== gesture.handlerTag) {\n        continue;\n      }\n\n      if (isStateChangeEvent(event)) {\n        if (\n          event.oldState === State.UNDETERMINED &&\n          event.state === State.BEGAN\n        ) {\n          runWorklet(CALLBACK_TYPE.BEGAN, gesture, event);\n        } else if (\n          (event.oldState === State.BEGAN ||\n            event.oldState === State.UNDETERMINED) &&\n          event.state === State.ACTIVE\n        ) {\n          runWorklet(CALLBACK_TYPE.START, gesture, event);\n          lastUpdateEvent.value[gesture.handlerTag] = undefined;\n        } else if (\n          event.oldState !== event.state &&\n          event.state === State.END\n        ) {\n          if (event.oldState === State.ACTIVE) {\n            runWorklet(CALLBACK_TYPE.END, gesture, event, true);\n          }\n          runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, true);\n        } else if (\n          (event.state === State.FAILED || event.state === State.CANCELLED) &&\n          event.state !== event.oldState\n        ) {\n          if (event.oldState === State.ACTIVE) {\n            runWorklet(CALLBACK_TYPE.END, gesture, event, false);\n          }\n          runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, false);\n        }\n      } else if (isTouchEvent(event)) {\n        if (!stateControllers[i]) {\n          stateControllers[i] = GestureStateManager.create(event.handlerTag);\n        }\n\n        if (event.eventType !== TouchEventType.UNDETERMINED) {\n          runWorklet(\n            touchEventTypeToCallbackType(event.eventType),\n            gesture,\n            event,\n            stateControllers[i]\n          );\n        }\n      } else {\n        runWorklet(CALLBACK_TYPE.UPDATE, gesture, event);\n\n        if (gesture.onChange && gesture.changeEventCalculator) {\n          runWorklet(\n            CALLBACK_TYPE.CHANGE,\n            gesture,\n            gesture.changeEventCalculator?.(\n              event,\n              lastUpdateEvent.value[gesture.handlerTag]\n            )\n          );\n\n          lastUpdateEvent.value[gesture.handlerTag] = event;\n        }\n      }\n    }\n  };\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const event = Reanimated.useEvent(\n    callback,\n    ['onGestureHandlerStateChange', 'onGestureHandlerEvent'],\n    needsRebuild\n  );\n\n  preparedGesture.animatedEventHandler = event;\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}